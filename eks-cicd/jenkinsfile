pipeline {
  agent any

  environment {
    VAULT_ADDR = 'http://127.0.0.1:8200'
    TF_VAR_aws_region = 'us-east-1'
    DOCKER_IMAGE = 'jenkins-tools:latest'
  }

  stages {
    stage('Build Docker Image') {
      steps {
        dir('eks-cicd') {
          sh 'docker build -t $DOCKER_IMAGE -f Dockerfile .'
        }
      }
    }

    stage('Run CI in Docker') {
      agent {
        docker {
          image "${DOCKER_IMAGE}"
          args '-u root:root'
        }
      }

      environment {
        VAULT_ADDR = 'http://127.0.0.1:8200'
        TF_VAR_aws_region = 'us-east-1'
      }

      stages {

        stage('Check Tools') {
          steps {
            sh '''
              echo "--- Versions Check ---"
              vault --version || echo "Missing vault"
              terraform --version || echo "Missing terraform"
              aws --version || echo "Missing aws"
              jq --version || echo "Missing jq"
            '''
          }
        }

        stage('Start Vault') {
          steps {
            sh '''
              set -e

              mkdir -p /vault/data

              echo ">>> Starting Vault server..."
              nohup vault server -config=eks-cicd/vault/vault.hcl > vault.log 2>&1 &

              echo ">>> Waiting for Vault to be ready..."
              for i in {1..10}; do
                if curl -s http://127.0.0.1:8200/v1/sys/health | grep -q initialized; then
                  echo "Vault is ready."
                  break
                fi
                echo "Waiting..."
                sleep 2
              done

              export VAULT_ADDR=http://127.0.0.1:8200

              if ! vault status | grep -q "Initialized.*true"; then
                echo ">>> Initializing Vault..."
                vault operator init -key-shares=1 -key-threshold=1 -format=json > init.json
              fi

              vault operator unseal $(jq -r .unseal_keys_b64[0] init.json)
              vault login $(jq -r .root_token init.json)

              echo ">>> Optional: Load test secret into Vault"
              vault kv put aws/terraform-project \
                aws_access_key_id=TESTKEY123 \
                aws_secret_access_key=TESTSECRET123
            '''
          }
        }

        stage('Fetch AWS Credentials from Vault') {
          steps {
            script {
              try {
                echo "üîê Fetching AWS credentials from Vault..."
                def creds = sh(
                  script: '''
                    set -ex
                    vault kv get -format=json aws/terraform-project
                  ''',
                  returnStdout: true
                ).trim()

                echo "üì¶ Raw Vault output: ${creds.take(200)}..."

                def parsed = readJSON text: creds
                env.AWS_ACCESS_KEY_ID     = parsed.data.data.aws_access_key_id
                env.AWS_SECRET_ACCESS_KEY = parsed.data.data.aws_secret_access_key

                echo "‚úÖ AWS credentials loaded successfully."
              } catch (Exception e) {
                echo "‚ùå Failed to fetch AWS credentials: ${e.message}"
                error("Vault fetch failed. Please check Vault status or secret path.")
              }
            }
          }
        }

        stage('Terraform Init & Plan') {
          steps {
            dir('eks-cicd/infra') {
              withEnv([
                "AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID}",
                "AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY}",
                "TF_VAR_aws_region=${env.TF_VAR_aws_region}"
              ]) {
                sh 'terraform init -reconfigure'
                sh 'terraform plan'
              }
            }
          }
        }

        stage('Terraform Apply') {
          steps {
            input "Apply infrastructure?"
            dir('eks-cicd/infra') {
              withEnv([
                "AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID}",
                "AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY}",
                "TF_VAR_aws_region=${env.TF_VAR_aws_region}"
              ]) {
                sh 'terraform apply -auto-approve'
              }
            }
          }
        }

        stage('Update Kubeconfig') {
          steps {
            withEnv([
              "AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID}",
              "AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY}"
            ]) {
              sh 'aws eks update-kubeconfig --region us-east-1 --name EKS-CLUSTER321'
            }
          }
        }
      }

      post {
        always {
          echo 'üßπ Cleaning up Vault process...'
          sh 'pkill vault || true'
        }
      }
    }
  }
}
